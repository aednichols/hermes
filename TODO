2.0 TODO
========

Package Structure
-----------------

PEP-8: "Modules should have short, all-lowercase names. Underscores can be used in the module name if it improves readability. Python packages should also have short, all-lowercase names, although the use of underscores is discouraged."

PEP-8: "Class names should normally use the CapWords convention."

PEP-8: "Function names should be lowercase, with words separated by underscores as necessary to improve readability."

hermes - compile() to get back a parser, get_grammar() to get a CompositeGrammar
hermes.hermes_parser - bootstraped parser
hermes.factory - (currently hermes.parser) create() return CompositeGrammar
hermes.grammar
    CompositeGrammar, Rule, Production, Conflicts, Lexer, etc.  Internal data structures.
hermes.main - cli() and analyze() methods
hermes.code - Generates source code to parse grammar.  generate(), generate_internal()

Minor things
------------

1) Have error message if expression rule needs a binding power but is missing one. (Add test!)
2) Have error message if lexer produces token that is not consumed by the grammar.
3) Get rid of MacroGeneratedRule
4) Make test with macro for first part of expression rule.  Should this be a syntax error?
5) Test capital letters, numbers, underscores in terminal/nonterminal
6) All syntax errors need a test
7) Test two expression parsers in one grammar

Syntax Error Formatting for C
-----------------------------

parse() method takes tokens and syntax error formatter.  Optionally, a nonterminal to parse.

This creates a ParserContext which is passed around internally to the parser methods

ParserContext
  - tokens
  - syntax error formatter
  - rule
  - nonterminal

Document public interface for all targets
-----------------------------------------

Document the interface for the public classes (just CompositeGrammar?) in hermes.grammar:

  HermesGrammar:
    __init__(name, rules)
    start - self.rules[0].nonterminal
    rules - self.rules
    terminals - list of all terminals
    nonterminals - list of all nonterminals
    standard_terminals - list of terminals that are non-abstract (i.e. not :_empty and :_end)
    ll1_nonterminals - list of nonterminals that aren't expression nonterminals
    expression_nonterminals - list of expression nonterminals
    parse_table - 2x2 matrix [nonterminal][terminal] = rule
    must_consume_token(nonterminal) - returns true if there is no production such that $nonterminal = :_empty
    first(production|nonterminal) - list of terminals in first set
    follow(nonterminal) - list of terminals in follow set
    get_rules(nonterminal) - list of rules for this nonterminal
    get_expanded_rules(nonterminal) - list of expanded rules for this nonterminal
    __str__()

  Rule
    id - auto assigned integer identifier
    nonterminal - LHS of this rule
    is_empty - true if $nonterminal = :_empty
    production - Production object
    operator (optional) - Terminal
    __eq__(), __str__()

  Production:
    morphemes - list of morphemes in this production

  ExprRule(Rule)
    nud_production - Production
    led_production - Production
    nudAst - AstSpecification or AstTranslation
    ledAst - AstSpecification or AstTranslation
    __str__()

  NonTerminal, Terminal
    id - auto assigned integer identifier
    string - string representation, without leading $ or :

  Operator
    operator - Terminal of this operator
    associativity - ['left', 'right', 'unary']
    binding_power - integer binding power.  How closely this binds relative to other operators

  AstSpecification
    name
    parameters

  AstTranslation
    idx

  ------------------------

  Grammar
    - rules (Rule)
    - terminals
    - nonterminals
    - macros
    - start
    - must_consume_tokens(nonterminal) [is_empty]
    - is_standard_terminal(terminal)
    - is_abstract_terminal(terminal)
    - conflicts
  LL1Grammar(Grammar)
    - first (dict)
    - follow (dict)
  ExpressionGrammar(Grammar)
    - nud
    - led
    - precedence
  CompositeGrammar
    - ll1_grammar
    - expression_grammars
  LL1Rule
    - id, morphemes
    - nonterminal
    - production
  ExpressionRule
    - id, morphemes
    - nud
    - led
  NonTerminal
    - id, name
  Terminal
    - id, name

Document Python parser output format
------------------------------------

Python:
    default prefix = my_grammar.gr -> my_grammar
    files = <prefix>_parser.py

C:
    default prefix = my_grammar.gr -> my_grammar
    files = <prefix>_parser.c, <prefix>_parser.h

Java:
    default prefix = my_grammar.gr -> MyGrammar
    files = <prefix>Parser.java

JavaScript:
    default prefix = my_grammar.gr -> my_grammar
    files = <prefix>_parser.js

HPath (implement and document)
------------------------------

    A :: All 'A' nodes
    A/B :: All 'B' nodes that are children of 'A' nodes
    A//B :: All 'B' nodes that are descendents of 'A' nodes
    A/B/C :: All 'C' nodes that are children of 'B' nodes that are children of 'A' nodes
    A//B/C :: All 'C' nodes that are children of 'B' nodes that are descendents of 'A' nodes
    /A :: All top-level 'A' nodes
    /A[@attr] :: All 'attr' attributes of top level 'A' nodes
    A[@attr]/B :: All 'B' nodes that are children of 'attr' attributes on 'A' nodes
    A/*/C :: All 'C' nodes that are that are grandchildren of 'A' nodes
    A[0] :: First 'A' element
    /A[-1] :: Last root 'A' element
    A|B :: Select all 'A' or 'B' elements
    A//:T :: 'T' terminals that are descendents of 'A' nodes
    A[@attr]/:T :: 'T' terminals that are in the 'attr' attribute of 'A' nodes
    :T :: 'T' terminals
    :S|:T :: 'T' or 'S' terminals
    :* :: all terminals
    :T[value='val'] :: 'T' terminals with a value of 'val'
    :S[value>100] :: 'T' terminals with integer value greater than 100
    :T[0] :: First 'T' element

h2. HPath examples

(Grammar:
  body=[
    (Parser:
      rules=[
        (Rule:
          nonterminal=<nonterminal (line 1 col 21) `a`>,
          production=[
            (Production:
              morphemes=[
                <terminal (line 1 col 24) `b`>
              ],
              ast=None
            )
          ]
        ),
        (Rule:
          nonterminal=<nonterminal (line 2 col 1) `c`>,
          production=[
            (Production:
              morphemes=[
                <terminal (line 2 col 4) `d`>
              ],
              ast=None
            )
          ]
        )
      ]
    )
  ],
  code=None
)

Grammar :: Top level 'Grammar' AST
Rule :: both 'Rule' ASTs
Rule[@nonterminal] :: terminal elements for nonterminals 'a' and 'c'
Parser[@rules] :: both 'Rule' ASTs
:nonterminal :: 'a' and 'c' terminals
:* :: 'a', 'b', 'c', and 'd' terminals

h3. HPath algorithm

/Grammar[@body]/Parser[@rules]/Rule[@production]/Production
/Grammar/Parser/Rule/Production
/Grammar/Parser = /Grammar[@*]/Parser

(1) HPath is parsed as segments: `/Grammar[@body]`, `/Parser[@body]`, `/Rule[@production]`, `/Production`
(2) HPath segment have three parts:
  (2a) SCOPE: / or // (null=//)
  (2b) NAME: name of the AST to match, may be * to match any AST
  (2c) SPECIFIER: in square brackets... either an integer (index for lists), or a string "@attr" (attribute on an AST)
(3) CTX is a list of contexts.  A context contains a list of elements.  current(CTX) is the current context.
(3a) CTX = []
(4) Loop through the segments:
  (4a) current = new Context();
  (4b) If the SCOPE is /, current.add(elements CTX[-1] that match NAME/SPECIFIER)
  (4c) If the SCOPE is //, current.add(recursive elements of CTX[-1] that match NAME/SPECIFIER)
  (4d) CTX.append(current)
(5) Return CTX[-1]
