

# infix
a := a + '+' + a
a := {a} + {'+' + a}

# prefix
a := '-' + a
a := {'-' + a} {}

# mixfix
# Parse the first expression, save it in $$ then parse second expression
#
# Rules:
# 1.  root is at first token in the last group
a := {'i' -> $0} + {'lparen' + list(a) + 'rparen'} -> FuncCall( name=$$, params=$2 )

a := {'i'} + {'lparen' + list(a) + 'rparen'} -> FuncCall( name=$0, params=$2 )

a := {'x' + 'y' + 'z'}
a := {'x' + 'y' + 'z' -> $0}
a := {'x' + 'y' + 'z'} + {}

_expr := {'lparen' + type_name + 'rparen' -> $1} + {'lbrace' + list(initilizer_list_item, 'comma') + comma_opt + 'rbrace'} -> TypeInitializion( type=$1, initializer=$4 )

currently, assume the *whole thing* is a NUD function unless a root is specified at not the first node.

The rule is 'NUD with optional LED':

nud + led?
{nud -> NudDef()} + {led}? -> AstDef()
{'a' + b -> Foo( x=$1 )} -> Bar ( y=$0 ) # Bar( y=Foo( x=b ) )
{'a' + b -> $1} -> Bar( y=$0 )           # Bar( y=b )
{'a' + b -> $0} -> Bar( y=$0 )           # Bar( y='a' )
{'a' + b} -> Bar( y=$0 )                 # Bar( y='a' )
