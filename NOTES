NOTES and TODO
==============

Bugs
----

1.  Fix extraneous _genX tokens in expr.zgr
2.  Make unit tests pass after adding the new warning and conflict.

AST Transformations & Constraints
---------------------------------

[
  {
    "constraint": "FunctionDefinition.body is_a CompoundExpression",
    "message": "A function body must be a compound expression"
  },
  {
    "constraint": "FunctionDefinition.declarator.find(ParameterTypeList).count() == 1",
    "message": "A function body must be a compound expression"
  },
  {
    "transformation": "FunctionDefinition( name=declarator.ident, parameters=declarator.find(ParameterList), return=)"
  }
]

Test Granularity
----------------

1) Grammar file parsing
  a) no duplicate terminals/nonterminals
  b) no extra _genX nonterminals or rules
  c) test correctness of JUST the parsers alone, one by one.
  d) test the composite parser assuming that the sub parsers work
2) 

Expression Parsing
------------------
# infix
a := a + '+' + a
a := {a} + {'+' + a}

# prefix
a := '-' + a
a := {'-' + a} {}

# mixfix
# Parse the first expression, save it in $$ then parse second expression
#
# Rules:
# 1.  root is at first token in the last group
a := {'i' -> $0} + {'lparen' + list(a) + 'rparen'} -> FuncCall( name=$$, params=$2 )

a := {'i'} + {'lparen' + list(a) + 'rparen'} -> FuncCall( name=$0, params=$2 )

a := {'x' + 'y' + 'z'}
a := {'x' + 'y' + 'z' -> $0}
a := {'x' + 'y' + 'z'} + {}

_expr := {'lparen' + type_name + 'rparen' -> $1} + {'lbrace' + list(initilizer_list_item, 'comma') + comma_opt + 'rbrace'} -> TypeInitializion( type=$1, initializer=$4 )

currently, assume the *whole thing* is a NUD function unless a root is specified at not the first node.

The rule is 'NUD with optional LED':

nud + led?
{nud -> NudDef()} + {led}? -> AstDef()
{'a' + b -> Foo( x=$1 )} -> Bar ( y=$0 ) # Bar( y=Foo( x=b ) )
{'a' + b -> $1} -> Bar( y=$0 )           # Bar( y=b )
{'a' + b -> $0} -> Bar( y=$0 )           # Bar( y='a' )
{'a' + b} -> Bar( y=$0 )                 # Bar( y='a' )
