grammar {
  lexer<python> {
    r'(a)(b)(c)' -> :a[1] :b[2] :c[3] :abc[0]
    r'(x)\s*(y)\s*(z)' -> :hint[] f(:x[1]) :all
    r'\s+' -> null
    <code>
def f(context, mode, match, groups, terminal, resource, line, col):
    return default_action(context, mode, match, groups, terminal, resource, line, col)
    </code>
  }
  lexer<c> {
    "(a)(b)(c)" -> :a[1] :b[2] :c[3] :abc[0]
    "(x)\\s*(y)\\s*(z)" -> :hint[] f(:x[1]) :all
    "\\s+" -> null
    mode<test> {
      "\\s+" -> null
    }
    <code>
static LEXER_MATCH_T * f(void * context, char * mode, char * source_string, char ** match_groups, TERMINAL_T * terminal, char * resource, int line, int col)
{
    return default_action(context, mode, source_string, match_groups, terminal, resource, line, col);
}
    </code>
  }
  lexer<java> {
    "(a)(b)(c)" -> :a[1] :b[2] :c[3] :abc[0]
    "(x)\\s*(y)\\s*(z)" -> :hint[] f(:x[1]) :all
    "\\s+" -> null
    mode<test> {
      "\\s+" -> null
    }
    <code>
public LexerMatch f(Object context, String mode, String match, GrammarTerminalIdentifier terminal, String resource, int line, int col) {
    return default_action(context, mode, match, terminal, resource, line, col);
}
    </code>
  }
  lexer<javascript> {
    "(a)(b)(c)" -> :a[1] :b[2] :c[3] :abc[0]
    "(x)\\s*(y)\\s*(z)" -> :hint[] f(:x[1]) :all
    "\\s+" -> null
    mode<test> {
      "\\s+" -> null
    }
    <code>
function f(context, mode, match, terminal, resource, line, col) {
    return default_action(context, mode, match, terminal, resource, line, col);
}
    </code>
  }
}
