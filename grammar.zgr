{
  "ll1": {
    "start": "grammar",
    "rules": [
      "grammar := 'grammar' + 'lbrace' + list(body_element) + 'rbrace' + optional('code') -> Grammar(body=$2, code=$4)",
      "body_element := body_element_sub",
      "body_element_sub := lexer | parser",
      "lexer := 'lexer' + 'lbrace' + list(lexer_atom) + 'rbrace' -> Lexer(atoms=$2)",
      "lexer_atom := lexer_regex | lexer_mode",
      "lexer_regex := 'regex' + optional(regex_options) + 'arrow' + lexer_target -> Regex(regex=$0, options=$1, onmatch=$3)",
      "regex_options := 'lbrace' + list('identifier') + 'rbrace' -> $1",
      "lexer_target := 'terminal'",
      "lexer_target := 'identifier' + 'lparen' + optional('terminal') + 'rparen'-> LexerFunctionCall(name=$0, terminal=$2)",
      "lexer_target := 'null' -> Null()",
      "lexer_mode := 'mode' + 'langle' + 'identifier' + 'rangle' + 'lbrace' + list(lexer_atom) + 'rbrace' -> Mode(name=$2, atoms=$5)",
      "parser := parser_ll1 | parser_expression",
      "parser_ll1 := 'parser_ll1' + 'lbrace' + list(ll1_rule) + 'rbrace' -> Parser(rules=$2)",
      "ll1_rule := 'll1_rule_hint' + 'nonterminal' + 'equals' + ll1_rule_rhs -> Rule(nonterminal=$1, production=$3)",
      "ll1_rule_rhs := list(rule, 'pipe')",
      "rule := list(morpheme) + optional(ast_transform) -> Production(morphemes=$0, ast=$1)",
      "ll1_rule_rhs := 'null' -> NullProduction()",
      "ll1_rule_rhs := parser",
      "parser_expression := 'parser_expression' + 'lbrace' + list(expression_rule) + 'rbrace' -> ExpressionParser(rules=$2)",
      "expression_rule := optional(binding_power) + 'expr_rule_hint' + 'nonterminal' + 'equals' + expression_rule_production -> ExpressionRule(precedence=$0, nonterminal=$2, production=$4)",
      "expression_rule_production := 'mixfix_rule_hint' + nud + optional(ast_transform) + optional(led) + optional(ast_transform) -> MixfixProduction(nud=$1, nud_ast=$2, led=$3, ast=$4)",
      "expression_rule_production := 'prefix_rule_hint' + list(morpheme) + optional(ast_transform) -> PrefixProduction(morphemes=$1, ast=$2)",
      "expression_rule_production := 'infix_rule_hint' + list(morpheme) + optional(ast_transform) -> InfixProduction(morphemes=$1, ast=$2)",
      "nud := list(morpheme)",
      "led := 'expression_divider' + list(morpheme) -> $1",
      "binding_power := 'lparen' + precedence + 'rparen' -> $1",
      "precedence := binding_power_marker + 'colon' + associativity -> Precedence(marker=$0, associativity=$2)",
      "binding_power_marker := 'asterisk' | 'dash'",
      "associativity := 'left' | 'right' | 'unary'",
      "morpheme := 'terminal' | 'nonterminal' | macro",
      "ast_transform := 'arrow' + ast_transform_sub -> $1",
      "ast_transform_sub := 'identifier' + 'lparen' + list(ast_parameter, 'comma') + 'rparen' -> AstTransformation(name=$0, parameters=$2)",
      "ast_transform_sub := 'nonterminal_reference'",
      "ast_parameter := 'identifier' + 'equals' + 'nonterminal_reference' -> AstParameter(name=$0, index=$2)",
      "macro := 'identifier' + 'lparen' + list(macro_parameter, 'comma') + 'rparen' -> Macro(name=$0, parameters=$2)",
      "macro_parameter := 'nonterminal' | 'terminal'"
    ]
  }
}
