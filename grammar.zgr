{
  "ll1": {
    "start": "grammar",
    "rules": [
      "grammar := 'grammar' + 'lbrace' + list(body_element) + 'rbrace' + 'code' -> Grammar(body=$2, code=$4)",
      "body_element := body_element_sub",
      "body_element_sub := lexer | parser",
      "lexer := 'lexer' + 'lbrace' + list(lexer_atom) + 'rbrace' -> Lexer(atoms=$2)",
      "lexer_atom := lexer_regex | lexer_mode",
      "lexer_regex := 'regex' + optional(regex_options) + 'arrow' + lexer_target -> Regex(regex=$0, onmatch=$3)",
      "regex_options := 'lbrace' + list('identifier') + 'rbrace'",
      "lexer_target := 'terminal' -> Terminal(name=$0)",
      "lexer_target := 'identifier' + 'lparen' + 'terminal' + 'rparen'-> LexerFunctionCall(name=$0, terminal=$2)",
      "lexer_target := 'null' -> Null()",
      "lexer_mode := 'mode' + 'langle' + 'identifier' + 'rangle' + 'lbrace' + list(lexer_atom) + 'rbrace' -> Mode(name=$2, atoms=$5)",
      "parser := parser_ll1 | parser_expression",
      "parser_ll1 := 'parser_ll1' + 'lbrace' + list(ll1_rule) + 'rbrace' -> Parser(rules=$2)",
      "ll1_rule := 'll1_rule_hint' + 'nonterminal' + 'equals' + ll1_rule_rhs -> Rule(nonterminal=$1, production=$3)",
      "ll1_rule_rhs := list(rule, 'pipe')",
      "rule := list(morpheme) + optional(ast_transform) -> Production(morphemes=$0, ast=$1)",
      "ll1_rule_rhs := 'null' -> NullProduction()",
      "ll1_rule_rhs := parser",
      "parser_expression := 'parser_expression' + 'lbrace' + list(expression_rule) + 'rbrace' -> ExpressionParser(rules=$2)",
      "expression_rule := 'lparen' + precedence + 'rparen' + 'nonterminal' + 'equals' + list(expression_morpheme) + optional(ast_transform) -> ExpressionRule(precedence=$1, nonterminal=$3, production=$5, ast=$6)",
      "precedence := binding_power_marker + 'colon' + associativity -> Precedence(marker=$0, associativity=$2)",
      "binding_power_marker := 'asterisk' | 'dash'",
      "associativity := 'left' | 'right' | 'unary'",
      "expression_morpheme := morpheme | 'expression_divider'",
      "morpheme := 'terminal' | 'nonterminal' | macro",
      "ast_transform := 'arrow' + ast_transform_sub -> $1",
      "ast_transform_sub := 'identifier' + 'lparen' + list(ast_parameter, 'comma') + 'rparen' -> AstTransformation(name=$0, parameters=$2)",
      "ast_transform_sub := 'nonterminal_reference'",
      "ast_parameter := 'identifier' + 'equals' + 'nonterminal_reference' -> AstParameter(name=$0, index=$2)",
      "macro := 'identifier' + 'lparen' + list(macro_parameter, 'comma') + 'rparen' -> Macro(name=$0, parameters=$2)",
      "macro_parameter := 'nonterminal' | 'terminal'"
    ]
  }
}
