{
  "ll1": {
    "start": "grammar",
    "rules": [
      "grammar := 'grammar' + 'lbrace' + list(body_element) + 'rbrace' + 'code' -> Grammar(body=$1, code=$3)",
      "body_element := body_element_sub",
      "body_element_sub := lexer | parser",
      "lexer := 'lexer' + 'lbrace' + list(lexer_atom) + 'rbrace' -> Lexer(atoms=$2)",
      "lexer_atom := lexer_regex | lexer_mode",
      "lexer_regex := 'regex' + 'arrow' + lexer_target -> Regex(regex=$0, onmatch=$2)",
      "lexer_target := 'terminal' -> Terminal(name=$0)",
      "lexer_target := 'function' -> FunctionCall(name=$0)",
      "lexer_target := 'null' -> Null()",
      "lexer_mode := 'mode' + 'langle' + 'identifier' + 'rangle' + 'lbrace' + list(lexer_atom) + 'rbrace' -> Mode(name=$2, atoms=$5)",
      "parser := parser_ll1 | parser_expression",
      "parser_ll1 := 'parser_ll1' + 'lbrace' + list(ll1_rule) + 'rbrace' -> Parser(rules=$2)",
      "ll1_rule := 'll1_rule_hint' +  'nonterminal' + 'equals' + list(morpheme) + optional(ast_transform) -> Rule(nonterminal=$1, production=$3, ast=$4)",
      "ll1_rule := 'll1_null_rule_hint' +  'nonterminal' + 'equals' + 'null' -> NullRule(nonterminal=$1)",
      "ll1_rule := 'subparser_hint' +  'nonterminal' + 'equals' + parser -> SubParser(nonterminal=$1, parser=$3)",
      "parser_expression := 'parser_expression' + 'lbrace' + list(expression_rule) + 'rbrace' -> ExpressionParser(rules=$2)",
      "expression_rule := 'lparen' + precedence + 'rparen' + 'nonterminal' + 'equals' + list(expression_morpheme) + optional(ast_transform) -> ExpressionRule(precedence=$1, nonterminal=$3, production=$5, ast=$6)",
      "precedence := binding_power_marker + 'colon' + associativity -> Precedence(marker=$0, associativity=$2)",
      "binding_power_marker := 'asterisk' | 'dash'",
      "associativity := 'left' | 'right' | 'unary'",
      "expression_morpheme := morpheme | 'expression_divider'",
      "morpheme := 'terminal' | 'nonterminal' | macro",
      "ast_transform := 'arrow' + 'identifier' + 'lparen' + list(ast_parameter, 'comma') + 'rparen' -> AstTransformation(name=$1, parameters=$3)",
      "ast_parameter := 'identifier' + 'equals' + 'nonterminal' -> AstParameter(name=$0, index=$2)",
      "macro := 'identifier' + 'lparen' + list(macro_parameter, 'comma') + 'rparen' -> Macro(name=$0, parameters=$2)",
      "macro_parameter := 'nonterminal' | 'terminal'"
    ]
  }
}
